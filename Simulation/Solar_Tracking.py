#coding: utf-8

# This is the combination of several scripts that download data from the NASA NSRDB database and process
# This code is adapted from original code written for the longevity ICDCS paper.
# The propose of this code it to run experiments around solar tracking for different solar use cases. 
# Original Code Greg Jackson 19/05/2016 AESE Labs Imperial College. gr3gario on twitter and gregario on github
# Tracking Paper Code Greg Jackson 6/03/2017 AESE Labs Imperial College. gr3gario on twitter and gregario on github

import pandas as pd
import sys, os, io
import time
import math
from datetime import date, datetime, timedelta
from termcolor import colored
import csv,simplejson
import itertools
from NREL import * 
import profile

output_jsons = [] # output file

def dfLoad(test):
	df = pd.read_csv('datasets/{}_solartracking_raw.csv'.format(test),low_memory=False,index_col=0) # change file name to loop
	return df

def getTemplist(df):
	temperature_list,result = df["Temperature"].tolist(),[]
	for item in temperature_list:
		if (type(item) == str) and item.endswith('.1'):
				item = item[:-2]
				result.append(float(item))
		else: result.append(float(item))
	return result

# This is a placeholder function to calculate azimuth from existing variables
def azimuthCalc(df):
	df['Azimuth Angle'] = azimuth * (df.shape[0]/len(azimuth)) 	# as it moves by 15 degrees per hour as long as we know the time we can calculate. This line expands array to fit data length (in multiples of 24 hours)
	return df

# Function to calculate the relative losses between solar position and current location of panel
def angleLoss(a,azimuth_position,b,elevation_position,c):
	if (b > 90) or (c > 90): output = 0 # This if statement let's output = input if elevation or azimuth are > 90. This takes care of strange COS issues when it's actually night time. 
	else: output = a*math.cos(math.radians(c - azimuth_position))*math.cos(math.radians(elevation_position-b)) # combining the two to see loss of energy production for static system 
	return output

def moveLossCalc(DOF,c,funct):
	if (DOF in 'static') or (c > 90): moveLoss = 0  # to account for 0 energy cost for tracking
	else:
		if DOF in '1DOF': moveLoss = ((curMotorStart + curMotor*DOF_index)/(1800))
		if DOF in '2DOF': moveLoss = ((curMotorStart + curMotor*DOF_index)/(1800))+((curMotorStart + curMotor*DOF2_index)/(1800))
	return moveLoss

# Converts solar energy to energy generation for a Solar Panel
def panelEnergyGen(df,E_list,moveLoss):
	temperature_list = getTemplist(df)
	tc_list = [(a+(((Noct-20)/800)*b)) for a,b in zip(temperature_list,E_list)]
	efficiency_pvg = [((solar_panel_efficiency * power_conditioning_efficiency) * (1-temperature_coefficient*(a-ref_cell_temp))) for a in tc_list]
	EG_list = [((a*(solar_panel_active_area_m2*b*1000.00)/(solar_panel_voltage))-c) for a,b,c in zip(E_list,efficiency_pvg,moveLoss)]
	#EG_list = [round(float(elem),2) for elem in EG_list] # conversion from w/m2 to energy generated by solar panel in mA
	return EG_list

def tradTrack(df,test,DOF):
	# Passes necessary info to lists
	GHI_list,Zenith_list,Azimuth_list,E_list,moveLoss = df["GHI"].tolist(),df["Solar Zenith Angle"].tolist(),df["Azimuth Angle"].tolist(),[],[]
	if (DOF in '1DOF') or (DOF in "static"): 
		if ('0A' in test) or ('0B' in test): elevation_position = 13.1
		if ('0C' in test) or ('0D' in test): elevation_position = 47.5
	
	if DOF in 'static': azimuth_position = 0 
	for a,b,c in zip(GHI_list,Zenith_list,Azimuth_list):
		if (DOF in '1DOF') or (DOF in '2DOF'): azimuth_position = c
		if DOF in '2DOF': elevation_position = b
		output = angleLoss(a,azimuth_position,b,elevation_position,c)
		E_list.append(output)
		moveLoss.append(moveLossCalc(DOF,c,'trad'))

	output_jsons.append({'source': test, 'test': 'tradTrack', 'DOF': DOF, 'current_gen':panelEnergyGen(df,E_list,moveLoss)})
	return df 

# This function creates a preduction of current energy generated. This is a palceholder and will be integrated into a final simulator when ready
def createPrediction(df):
	pred,predoutput,GHI_list,length = [0 for j in range(48)],[],df["GHI"].tolist(),1000 # This is updated at end of time window (next time window)
	for x in range(0, length):
		for a,b in zip(GHI_list,pred): 
			predoutput.append((b+a)*0.5)
		pred,predoutput = predoutput,[]
	df ['Prediction'] = pred
	return df

# This method designs a 1 Nw brute force operator for tracking. I guess I will call this at each time in final version for larger datasets
def bruteOptimisation(df,test,DOF): 
	GHI_list,Zenith_list,Azimuth_list,E_list,moveLoss,permut,index,loop_index,movement_index,energyGen,azimuth_position,elevation_position,maxPoweroutput,count = df["GHI"].tolist(),df["Solar Zenith Angle"].tolist(),df["Azimuth Angle"].tolist(),[],[],[],0,0,0,[],0,0,[],0
	min_output,max_output,min_output_list,max_output_list = 0,0,[],[]
	if debug: print "Calculating/Loading Permutations for experiment"
	rlen = sum(1 for item in GHI_list if item!=(0)) # Shortens the permutation loop to be just non zero values
	if (DOF in '1DOF'): 
		if ('0A' in test) or ('0B' in test): elevation_position = 13.1
		if ('0C' in test) or ('0D' in test): elevation_position = 47.5
	for line in itertools.product([False,True],repeat=rlen): # creates permutation for testing
		loop_index,movement_index,index,moveLoss,E_list,azi_change = 0,0,0,[],[],0
		for a,b,c in zip(GHI_list,Zenith_list,Azimuth_list): # The creation of movement loss can be optimised
			if a == 0: azimuth_position = 0
			else:
				if line[index]:
					azi_change = azimuth_position-c
					azimuth_position = c
					movement_index +=1 # Created to keep track how much we've moved considering it centers around 0 
				index+=1 # keeps track of where we are in the loop for non zero values (this should always be the same as the index of permu as one derives the other)
			output = angleLoss(a,azimuth_position,b,elevation_position,c)
			E_list.append(output)
			if movement_index != 0: 
				moveLoss.append(((curMotorStart + (curMotor*(abs(azi_change))))/1800)) 
				movement_index =0
			else:
				moveLoss.append(0)
		energyGen = panelEnergyGen(df,E_list,moveLoss)
		energyGenSum = sum(energyGen)
		index = 0
		if min_output > energyGenSum:
			min_output = energyGenSum
			min_output_list = line
		if max_output < energyGenSum:
			max_output = energyGenSum
			max_output_list = line

	output_jsons.append({'source': test, 'test': 'bruteOptimisation', 'DOF': DOF, 'cur_gen_min':min_output, 'cur_gen_min_list': min_output_list,'cur_gen_max': max_output,'cur_gen_max_list': max_output_list})
   	return df

def lightOptimisation(df,test,DOF):
	GHI_list,Zenith_list,Azimuth_list,E_list,moveLoss = df["GHI"].tolist(),df["Solar Zenith Angle"].tolist(),df["Azimuth Angle"].tolist(),[],[]
	if (DOF in '1DOF') or (DOF in "static"): 
		if ('0A' in test) or ('0B' in test): elevation_position = 13.1
		if ('0C' in test) or ('0D' in test): elevation_position = 47.5
	temperature_list = getTemplist(df)
	line = []
	azimuth_position = 0
	for a,b,c,d in zip(GHI_list,Zenith_list,Azimuth_list,temperature_list):
		if a == 0: azimuth_position = 0
		#CHeck at current location that energy gen

		E_list_no=angleLoss(a,azimuth_position,b,elevation_position,c)
		tc_no = (d+(((Noct-20)/800)*E_list_no))
		efficiency_pvg_no = ((solar_panel_efficiency) * (1-temperature_coefficient*(tc_no-ref_cell_temp)))
		power_gen_test_no = (((E_list_no*efficiency_pvg_no*solar_panel_active_area_m2*1000)/solar_panel_voltage))
		E_list_yes = angleLoss(a,c,b,elevation_position,c) # changed azimuth[count] to c
		tc_yes = (d+(((Noct-20)/800)*E_list_yes))
		efficiency_pvg_yes = ((solar_panel_efficiency) * (1-temperature_coefficient*(tc_yes-ref_cell_temp)))
		power_gen_test_yes = ((((E_list_yes*efficiency_pvg_yes*solar_panel_active_area_m2*1000)/solar_panel_voltage))-(((curMotorStart + curMotor*(abs(azimuth_position-c))))/1800))

		if (power_gen_test_yes) > (power_gen_test_no): 
			azimuth_position = c
			E_list.append(E_list_yes)
			moveLoss.append(((curMotorStart + (curMotor*(abs(azimuth_position-c))))/1800)) # (curMotor*(abs(azimuth_position-c))))/1800)
			line.append(azimuth_position)
		else:
			E_list.append(E_list_no)
			moveLoss.append(0)
			line.append(azimuth_position)

	output_jsons.append({'source': test, 'test': 'lightOptimisation', 'DOF': DOF,'movement':line, 'current_gen':panelEnergyGen(df,E_list,moveLoss)})

def dumpData(test):
		resultFile = open("datasets/test/{}_solartracking_results.json".format(test),'wb')
		simplejson.dump(output_jsons, resultFile)
		resultFile.close()


def main():
	for test in test_loop:
		df = dfLoad(test) # loads environmental variables from location and time defined in NREL.py. If not local it downloads them from the NREL database and parses them for use.
		df = azimuthCalc(df) # Adding in a azimuth calculation to the raw data files.
		if not df.empty:
			df = tradTrack(df,test,'static')
			if debug: print "TradTrack Calculated"
			df = tradTrack(df,test,'1DOF')
			if debug: print "1DOF Calculated"
			df = tradTrack(df,test,'2DOF')
			if debug: print "2DOF Calculated"
			#df = bruteOptimisation(df,test,'1DOF') 
			#lightOptimisation(df,test,'1DOF')
			dumpData(test)
			for key in output_jsons: print "sub_test {0} current gen {1}".format(key['test'],key['current_gen'])
			#print output_jsons
			#del output_jsons[:]
main()
#profile.run('main()') # Run this if you want timing
